/**
 * Types and function signatures for the load balancing extension.
 * 
 * No copyright notice for now I suppose.
 */

 
#ifndef LAIK_LB_H
#define LAIK_LB_H

#include "core.h"
#include "space.h"

// enum defining current load balancing state (before / after iteration)
// start: record starting time and return
// stop : calculate time difference (for weights) and create new partitioning
typedef enum {
    START_LB_SEGMENT,
    STOP_LB_SEGMENT
} Laik_LBState;

// enum defining currently available load balancing algorithms
typedef enum {
    LB_RCB,
    LB_HILBERT,
    LB_GILBERT
} Laik_LBAlgorithm;

// get algorithm enum from string
Laik_LBAlgorithm laik_strtolb(const char *str);

// get algorithm string from enum
const char *laik_get_lb_algorithm_name(Laik_LBAlgorithm algo);

//////////////////////
// sfc partitioners //
//////////////////////

// main space-filling curve function
void runSFCPartitioner(Laik_RangeReceiver *r, Laik_PartitionerParams *p);

// create new space-filling curve partitioner
Laik_Partitioner *laik_new_sfc_partitioner(double *weights, Laik_LBAlgorithm algo);

/////////////////////
// rcb partitioner //
/////////////////////

// main rcb function
void runRCBPartitioner(Laik_RangeReceiver *r, Laik_PartitionerParams *p);

// create new rcb partitioner
Laik_Partitioner *laik_new_rcb_partitioner(double *weights);

////////////////////
// load balancing //
////////////////////

// create and return new partitioning based on time measurements using an input-chosen load balancing algorithm
//
// when under a specific stopping threshold for a certain number of consecutive runs, load balancing stops
// when over a specific starting thershold for a certain number of consecutive runs, load balancing restarts
// two thresholds were chosen alongside patience counters to avoid oscillation
//
// returns null for the starting call, the same partitioning if nothing was changed (do not free this if you intend on using it afterwards!)
// or a different partitioning if something changed
Laik_Partitioning *laik_lb_balance(Laik_LBState state, Laik_Partitioning *partitioning, Laik_LBAlgorithm algorithm /*, double threshold*/);

// switch a data container to the new partitioning scheme generated by the load balancing function, free the old partitioning,
// swap the caller's pointers (i.e. *part now points to *npart) and set caller's npart to NULL (!) to avoid accidentally using it afterwards
//
// if both partitionings are the same, then the function does nothing
void laik_lb_switch_and_free(Laik_Partitioning **part, Laik_Partitioning **npart, Laik_Data *data, Laik_DataFlow flow);

#endif