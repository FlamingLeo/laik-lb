/* This file is part of the LAIK parallel container library.
 * Copyright (c) 2025 Flavius Schmidt
 *
 * LAIK is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, version 3.
 *
 * LAIK is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */


/**
 * Types and function signatures for the load balancing extension.
 */

#ifndef LAIK_LB_H
#define LAIK_LB_H

#include "core.h"
#include "space.h"

// enum defining current load balancing state (before / after iteration)
// start: record starting time and return
// stop : calculate time difference (for weights) and create new partitioning
typedef enum
{
    START_LB_SEGMENT,
    STOP_LB_SEGMENT,
    PAUSE_LB_SEGMENT,
    RESUME_LB_SEGMENT
} Laik_LBState;

// enum defining currently available load balancing algorithms
typedef enum
{
    LB_RCB,
    LB_RCB_INCR,
    LB_HILBERT,
    LB_GILBERT
} Laik_LBAlgorithm;

// convenience struct for data which will be benchmarked
typedef struct
{
    int mc;      // malloc count
    uint64_t mb; // malloc bytes
    int fc;      // freed count
    uint64_t fb; // freed bytes
    uint64_t bs; // bytes sent
    uint64_t br; // bytes received
} Laik_LBDataStats;

// get algorithm enum from string
Laik_LBAlgorithm laik_strtolb(const char *str);

// get algorithm string from enum
const char *laik_get_lb_algorithm_name(Laik_LBAlgorithm algo);

//////////////////////
// sfc partitioners //
//////////////////////

// main space-filling curve function
void runSFCPartitioner(Laik_RangeReceiver *r, Laik_PartitionerParams *p);

// create new space-filling curve partitioner
Laik_Partitioner *laik_new_sfc_partitioner(double *weights, Laik_LBAlgorithm algo);

/////////////////////
// rcb partitioner //
/////////////////////

// main rcb function
void runRCBPartitioner(Laik_RangeReceiver *r, Laik_PartitionerParams *p);

// main incremental rcb function
void runIncrementalRCBPartitioner(Laik_RangeReceiver *r, Laik_PartitionerParams *p);

// create new rcb partitioner
Laik_Partitioner *laik_new_rcb_partitioner(double *weights);

// create new incremental rcb partitioner
Laik_Partitioner *laik_new_incr_rcb_partitioner(double *weights);

////////////////////
// load balancing //
////////////////////

// create and return new partitioning based on time measurements using an input-chosen load balancing algorithm
//
// when under a specific stopping threshold for a certain number of consecutive runs, load balancing stops
// when over a specific starting thershold for a certain number of consecutive runs, load balancing restarts
// two thresholds were chosen alongside patience counters to avoid oscillation
//
// returns null for the starting call, the same partitioning if nothing was changed (do not free this if you intend on using it afterwards!)
// or a different partitioning if something changed
Laik_Partitioning *laik_lb_balance(Laik_LBState state, Laik_Partitioning *partitioning, Laik_LBAlgorithm algorithm /*, double threshold*/);

// switch a data container to the new partitioning scheme generated by the load balancing function, free the old partitioning,
// swap the caller's pointers (i.e. *part now points to *npart) and set caller's npart to NULL (!) to avoid accidentally using it afterwards
//
// if both partitionings are the same, then the function does nothing
void laik_lb_switch_and_free(Laik_Partitioning **part, Laik_Partitioning **npart, Laik_Data *data, Laik_DataFlow flow);

// free internal data structures (called on finalize)
void laik_lb_free();

// set custom weight array to be used
void laik_lb_set_ext_weights(double *weights);

// decide whether to print aggregated times in each step
void laik_lb_output(bool output);

// check if load balancing is currently stopped
bool laik_lb_is_stopped();

// decide if EMA should be used, and if so, optionally set new parameters (-1: leave default)
void laik_lb_config_smoothing(bool smoothing, double am, double rmi, double rma);

// configure start/stop parameters (-1: leave default)
void laik_lb_config_thresholds(int pstop, int pstart, double tstop, double tstart);

// print data statistics
void laik_lb_print_stats(int id);

// add external allocation statistic
void laik_lb_add_malloc(size_t size);

// add external free statistic
void laik_lb_add_free(size_t size);

// populate a stats data struct
void laik_lb_stats_store(Laik_LBDataStats *stats, Laik_Data *data);

// print diffs between two stat structs
void laik_lb_print_diff(int id, Laik_Data *data, Laik_LBDataStats *s1, Laik_LBDataStats *s2);

// set the tag for the partitioners
void laik_lb_set_tag(int t);

// increment the segment counter (ONLY do this if you know what you're doing!)
void laik_lb_incr_segment();

#endif